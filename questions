Questions tu session 14:
How do i implement/overwrite the asignment operator.
- solved the include copy.h with adding forward declarations of the matirx
    classes to isgematrix.h
The return type has to be the same, not void!

Questions to session 12:
downcast from std::complex<double> to std::complex<float> does give no
warning because the complex implementation compresses all warnings!!
dangerous because we could loose precission when implicit typecast happens
unwanted in an algorithm

The function ugemm that gets overloaded once. If the parameters have different
types it looks up to find a template to create it first,
before a typecast is invoced!

The Reference Implementation is used as "the simplest" version that can be
further optimized.

Questions to session 11:

Why do we use an interface?
wouldn't it be better to implement (copy paste) a direct version
to our new matrix class or changing the ones in bench.h ??
E.g. the assertions we have in our Matrix class are not invoced!
-> due to historic reasons. The extra functions calls doen't matter because
the compiler optimizes it away!

How to deal with the warnings about unused parameters?

What if I want to use a function created by a lamda expression more than once?
-> I can define the function as
    auto function = lambda exp.
and use later function with ()
or fuction as function pointer without parantheses

question 1 page 3:
The funcion object is created, when instantiated and ceases to exist, when it's
work is done. Meaning when the funcion gave back the return value.
It is a temporary object living on the stack.

question 2 page 3:
std::random_device()() needs to paares of parantheses because:
with the first we call the constructor,
with the second we make a call to itself to actually produce a uniformly
distributed random number as a seed for mt19937.




Question page 01:
1. the offset of two subsequent array accesses is incRowA * sizeof(double)
    = 1*8 = 8 bytes
2. n * 8 bytes because incRowA = n

3. becaues n > 1000 only one number is taken from each cashline loaded
    in the second case max 64/sizeof(double) = 8
    can be fetched from one cashline.
